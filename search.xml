<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>移动光度立体</title>
    <url>/2022/04/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
        <category>分类3</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
        <tag>标签3</tag>
      </tags>
  </entry>
  <entry>
    <title>传统光度立体法</title>
    <url>/2022/04/20/hello-world-1/</url>
    <content><![CDATA[<h3 id="一、头文件"><a href="#一、头文件" class="headerlink" title="一、头文件"></a>一、头文件</h3><h4 id="1-INCLUDE-FILES-h"><a href="#1-INCLUDE-FILES-h" class="headerlink" title="1.INCLUDE_FILES.h"></a>1.INCLUDE_FILES.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/quaternion.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/ply_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/radius_outlier_removal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/conditional_removal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926535898</span></span><br></pre></td></tr></table></figure>
<h4 id="2-struct-sfm-type-h"><a href="#2-struct-sfm-type-h" class="headerlink" title="2.struct_sfm_type.h"></a>2.struct_sfm_type.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;INCLUDE_FILES.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">POINT_3D</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> point3d_id;</span><br><span class="line">	<span class="type">double</span> X;</span><br><span class="line">	<span class="type">double</span> Y;</span><br><span class="line">	<span class="type">double</span> Z;</span><br><span class="line">	<span class="type">int</span> R;</span><br><span class="line">	<span class="type">int</span> G;</span><br><span class="line">	<span class="type">int</span> B;</span><br><span class="line">	<span class="type">double</span> ERROR_S;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; IMAGE_ID;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; POINT2D_IDX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">POINT_2D</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> IMAGE_ID;</span><br><span class="line">	vector&lt;<span class="type">double</span>&gt; X;</span><br><span class="line">	vector&lt;<span class="type">double</span>&gt; Y;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; point3d_id;</span><br><span class="line">	string belong_img;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUATERNION</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> IMAGE_ID;</span><br><span class="line">	<span class="type">double</span> QW;</span><br><span class="line">	<span class="type">double</span> QX;</span><br><span class="line">	<span class="type">double</span> QY;</span><br><span class="line">	<span class="type">double</span> QZ;</span><br><span class="line">	<span class="type">double</span> TX;</span><br><span class="line">	<span class="type">double</span> TY;</span><br><span class="line">	<span class="type">double</span> TZ;</span><br><span class="line">	<span class="type">int</span> CAMERA_ID;</span><br><span class="line">	string NAME;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PS_FORMAT</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//一张图片-&gt;一个像素值-&gt;一个光照</span></span><br><span class="line">	<span class="type">int</span> image_id;<span class="comment">//图像编号</span></span><br><span class="line">	<span class="comment">//cv::Mat image;//图像</span></span><br><span class="line">	<span class="comment">//cv::Mat mask;//图像</span></span><br><span class="line">	<span class="type">double</span> pixels;<span class="comment">//像素值</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//像素的x值</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//像素的y值</span></span><br><span class="line">	Eigen::Vector3d Lights;<span class="comment">//光照</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CAMERA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> CAMERA_ID;</span><br><span class="line">	string MODEL;</span><br><span class="line">	<span class="type">int</span> WIDTH;</span><br><span class="line">	<span class="type">int</span> HEIGHT;</span><br><span class="line">	<span class="type">double</span> f;</span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="type">double</span> unknown;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-func-ps-h"><a href="#3-func-ps-h" class="headerlink" title="3.func_ps.h"></a>3.func_ps.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;INCLUDE_FILES.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">prctile</span><span class="params">(cv::Mat m, <span class="type">int</span> per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> hist[<span class="number">256</span>], count = <span class="number">0</span>, aimnum = <span class="number">0</span>;</span><br><span class="line">	uchar* data;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">		hist[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data = m.<span class="built_in">ptr</span>&lt;uchar&gt;(i);<span class="comment">//data=m第i行第一个元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m.cols; j++)</span><br><span class="line">			hist[data[j]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	count = m.rows * m.cols * per / <span class="number">100.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hist[i] = hist[i - <span class="number">1</span>] + hist[i];</span><br><span class="line">		<span class="keyword">if</span> (count &lt;= hist[i])</span><br><span class="line">		&#123;</span><br><span class="line">			aimnum = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> aimnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dotmul</span><span class="params">(cv::Mat &amp;m, <span class="type">double</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span>* data;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data = m.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			data[j] = data[j] * rate;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maskshadow</span><span class="params">(vector&lt;cv::Mat&gt; imgs, vector&lt;cv::Mat&gt; &amp;mask, <span class="type">double</span> shadowThresh, <span class="type">int</span> g_pic_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Mat se;</span><br><span class="line">	se = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_ELLIPSE, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g_pic_num; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat temp = cv::<span class="built_in">Mat</span>(imgs[k].rows, imgs[k].cols, CV_8UC1);</span><br><span class="line">		<span class="type">double</span>* data;</span><br><span class="line">		uchar*tmp;</span><br><span class="line">		<span class="comment">//遍历图像</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; imgs[k].rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			data = imgs[k].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);<span class="comment">//行指针</span></span><br><span class="line">			tmp = temp.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; imgs[k].cols; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (data[j] / <span class="number">255</span> &gt; shadowThresh)</span><br><span class="line">					tmp[j] = <span class="number">255</span>;<span class="comment">//设置的阈值，如果大于阈值设置为255</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tmp[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cv::Mat dst;<span class="comment">//输出图像</span></span><br><span class="line">		cv::<span class="built_in">erode</span>(temp, dst, se);</span><br><span class="line">		mask.<span class="built_in">push_back</span>(dst);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; arrays)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrays.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arrays[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			cout &lt;&lt; arrays[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PhotometricStereo</span><span class="params">(vector&lt;cv::Mat&gt; imgs, vector&lt;cv::Mat&gt; mask, <span class="type">double</span> **L, vector&lt;cv::Mat&gt; &amp;n, <span class="type">int</span> g_pic_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mask[i].<span class="built_in">convertTo</span>(mask[i], CV_64FC1);</span><br><span class="line">		mask[i] = mask[i] / <span class="number">255</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> code_num = <span class="built_in">pow</span>(<span class="number">2</span>, g_pic_num);<span class="comment">//本节所使用的编码方式</span></span><br><span class="line">	<span class="type">int</span> numc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">table</span>(code_num);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; tempp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; code_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tempp.<span class="built_in">clear</span>();</span><br><span class="line">		numc = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g_pic_num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (numc % <span class="number">2</span>) </span><br><span class="line">				tempp.<span class="built_in">push_back</span>(g_pic_num - <span class="number">1</span> - j);</span><br><span class="line">			numc = numc / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		table[i] = tempp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Rows = <span class="number">0</span>, Cols = <span class="number">0</span>, locate = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> rho1 = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">	Rows = mask[<span class="number">0</span>].rows;</span><br><span class="line">	Cols = mask[<span class="number">0</span>].cols;</span><br><span class="line">	cv::Mat Nx = cv::Mat::<span class="built_in">zeros</span>(Rows, Cols, CV_64FC1);</span><br><span class="line">	cv::Mat Ny = cv::Mat::<span class="built_in">zeros</span>(Rows, Cols, CV_64FC1);</span><br><span class="line">	cv::Mat Nz = cv::Mat::<span class="built_in">zeros</span>(Rows, Cols, CV_64FC1);</span><br><span class="line">	cv::Mat mask_code = cv::Mat::<span class="built_in">zeros</span>(Rows, Cols, CV_64FC1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_pic_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mask_code = mask_code * <span class="number">2</span> + mask[i];<span class="comment">//编码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">table_row</span>(code_num);<span class="comment">//64 = pow(2,6)</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">table_col</span>(code_num);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> *p_row;<span class="comment">//行指针</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; Rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		p_row = mask_code.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(row);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; Cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			locate = (<span class="type">int</span>)p_row[col];</span><br><span class="line">			table_row[locate].<span class="built_in">push_back</span>(row);</span><br><span class="line">			table_col[locate].<span class="built_in">push_back</span>(col);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> *data0, *data1, *datax, *datay, *dataz;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; code_num; m++)</span><br><span class="line">	&#123;</span><br><span class="line">		count = table[m].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span> (count &gt; <span class="number">3</span> &amp;&amp; table_row[m].<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cv::Mat LL = cv::<span class="built_in">Mat</span>(count, <span class="number">3</span>, CV_64FC1);</span><br><span class="line">			cv::Mat I = cv::<span class="built_in">Mat</span>(count, table_row[m].<span class="built_in">size</span>(), CV_64FC1);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; count; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				data0 = I.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(k);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; table_row[m].<span class="built_in">size</span>(); i++)</span><br><span class="line">				&#123;</span><br><span class="line">					data1 = imgs[table[m][count - <span class="number">1</span> - k]].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(table_row[m][i]);</span><br><span class="line">					data0[i] = data1[table_col[m][i]];</span><br><span class="line">				&#125;</span><br><span class="line">				data0 = LL.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(k);</span><br><span class="line">				data0[<span class="number">0</span>] = L[<span class="number">0</span>][table[m][count - <span class="number">1</span> - k]];</span><br><span class="line">				data0[<span class="number">1</span>] = L[<span class="number">1</span>][table[m][count - <span class="number">1</span> - k]];</span><br><span class="line">				data0[<span class="number">2</span>] = L[<span class="number">2</span>][table[m][count - <span class="number">1</span> - k]];</span><br><span class="line">			&#125;</span><br><span class="line">			cv::Mat N = cv::<span class="built_in">Mat</span>(<span class="number">3</span>, table_row[m].<span class="built_in">size</span>(), CV_64FC1);</span><br><span class="line">			cv::<span class="built_in">solve</span>(LL, I, N, cv::DECOMP_SVD);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; table_row[m].<span class="built_in">size</span>(); i++)</span><br><span class="line">			&#123;</span><br><span class="line">				data0 = N.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>);</span><br><span class="line">				x = data0[i];</span><br><span class="line">				data0 = N.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>);</span><br><span class="line">				y = data0[i];</span><br><span class="line">				data0 = N.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>);</span><br><span class="line">				z = data0[i];</span><br><span class="line">				rho1 = <span class="built_in">sqrt</span>(x*x + y * y + z * z);</span><br><span class="line">				datax = Nx.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(table_row[m][i]);</span><br><span class="line">				datay = Ny.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(table_row[m][i]);</span><br><span class="line">				dataz = Nz.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(table_row[m][i]);</span><br><span class="line">				datax[table_col[m][i]] = x / rho1;</span><br><span class="line">				datay[table_col[m][i]] = y / rho1;</span><br><span class="line">				dataz[table_col[m][i]] = z / rho1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n.<span class="built_in">push_back</span>(Nx);</span><br><span class="line">	n.<span class="built_in">push_back</span>(Ny);</span><br><span class="line">	n.<span class="built_in">push_back</span>(Nz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComputeGradient</span><span class="params">(cv::Mat &amp;p, cv::Mat &amp;q, vector&lt;cv::Mat&gt; &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> row, col;</span><br><span class="line">	row = n[<span class="number">0</span>].rows;</span><br><span class="line">	col = n[<span class="number">0</span>].cols;</span><br><span class="line">	<span class="type">double</span> *n_z, *n_x, *n_y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			n_z = n[<span class="number">2</span>].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">			<span class="keyword">if</span> (n_z[j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> *p_1, *q_1;</span><br><span class="line">				p_1 = p.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				q_1 = q.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				p_1[j] = <span class="number">0</span>;</span><br><span class="line">				q_1[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> *p_1, *q_1;</span><br><span class="line">				n_x = n[<span class="number">0</span>].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				n_y = n[<span class="number">1</span>].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				n_z = n[<span class="number">2</span>].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				p_1 = p.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				q_1 = q.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">				p_1[j] = -n_x[j] / n_z[j];</span><br><span class="line">				q_1[j] = -n_y[j] / n_z[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Poisson_Solver</span><span class="params">(cv::Mat p, cv::Mat q, cv::Mat &amp;Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> row = p.rows;</span><br><span class="line">	<span class="type">int</span> col = p.cols;</span><br><span class="line">	cv::Mat gxx = p.<span class="built_in">clone</span>();</span><br><span class="line">	cv::Mat gyy = q.<span class="built_in">clone</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			gxx.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = p.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) - p.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			gyy.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = q.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) - q.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i - <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat f = gxx + gyy;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; f.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; f.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (f.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) != f.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col))</span><br><span class="line">			&#123;</span><br><span class="line">				f.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat fcos;</span><br><span class="line">	cv::<span class="built_in">dct</span>(f, fcos);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> denom = <span class="number">0</span>;</span><br><span class="line">	col = col;</span><br><span class="line">	row = row;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		denom = <span class="number">2</span> * <span class="built_in">cos</span>(PI*(<span class="type">double</span>)j / col) - <span class="number">2</span> + <span class="number">2</span> * <span class="built_in">cos</span>(PI*<span class="number">0.0</span> / row) - <span class="number">2</span>;</span><br><span class="line">		fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, j) = fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, j) / denom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			denom = <span class="number">2</span> * <span class="built_in">cos</span>(PI*(<span class="type">double</span>)j / col) - <span class="number">2</span> + <span class="number">2</span> * <span class="built_in">cos</span>(PI*(<span class="type">double</span>)i / row) - <span class="number">2</span>;</span><br><span class="line">			fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) / denom;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Z = fcos.clone();</span></span><br><span class="line">	cv::<span class="built_in">idct</span>(fcos, Z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthFromGradient</span><span class="params">(cv::Mat &amp;Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> maxZ, minZ;</span><br><span class="line">	pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">	cloud-&gt;width = Z.cols;</span><br><span class="line">	cloud-&gt;height = Z.rows;</span><br><span class="line">	cloud-&gt;points.<span class="built_in">resize</span>(cloud-&gt;width*cloud-&gt;height);</span><br><span class="line">	cv::Mat Htest, Hshow;</span><br><span class="line">	Htest = Z.<span class="built_in">clone</span>();</span><br><span class="line">	<span class="type">double</span> *p0;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Z.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p0 = Htest.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Z.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cloud-&gt;points[i*Z.cols + j].x = j;</span><br><span class="line">			cloud-&gt;points[i*Z.cols + j].y = i;</span><br><span class="line">			cloud-&gt;points[i*Z.cols + j].z = p0[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt; <span class="title">viewer</span><span class="params">(<span class="keyword">new</span> pcl::visualization::PCLVisualizer(<span class="string">&quot;3D Viewer&quot;</span>))</span></span>;</span><br><span class="line">	pcl::<span class="function">visualization::PointCloudColorHandlerGenericField&lt;pcl::PointXYZ&gt; <span class="title">fildColor</span><span class="params">(cloud, <span class="string">&quot;z&quot;</span>)</span></span>;</span><br><span class="line">	viewer-&gt;<span class="built_in">addPointCloud</span>&lt;pcl::PointXYZ&gt;(cloud, fildColor, <span class="string">&quot;sample cloud&quot;</span>);</span><br><span class="line">	viewer-&gt;<span class="built_in">setPointCloudRenderingProperties</span>(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, <span class="number">1</span>, <span class="string">&quot;sample cloud&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (!viewer-&gt;<span class="built_in">wasStopped</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		viewer-&gt;<span class="built_in">spinOnce</span>(<span class="number">100</span>);</span><br><span class="line">		boost::this_thread::<span class="built_in">sleep</span>(boost::posix_time::<span class="built_in">microseconds</span>(<span class="number">100000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">photometric_nomask</span><span class="params">(vector&lt;cv::Mat&gt; I, vector&lt;cv::Mat&gt; mask, <span class="type">double</span> **L,vector&lt;cv::Mat&gt; &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> M = I.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> N1 = I[<span class="number">0</span>].rows;</span><br><span class="line">	<span class="type">int</span> N2 = I[<span class="number">0</span>].cols;</span><br><span class="line">	<span class="function">cv::Mat <span class="title">I_mat</span><span class="params">(<span class="number">6</span>, N1*N2, CV_64FC1)</span></span>;</span><br><span class="line">	cv::Mat LL_t;</span><br><span class="line">	cv::Mat LL_inv;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; I.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat temp_mat = I[i].<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		temp_mat.<span class="built_in">copyTo</span>(I_mat.<span class="built_in">row</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat LL = cv::Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">6</span>, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">			LL.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = L[i][j];</span><br><span class="line">	cv::<span class="built_in">transpose</span>(LL, LL_t);</span><br><span class="line">	</span><br><span class="line">	cv::<span class="built_in">invert</span>(LL_t, LL_inv, cv::DECOMP_SVD);</span><br><span class="line">	cv::Mat b = LL_inv * I_mat;</span><br><span class="line">	vector&lt;cv::Mat&gt; b_reshape;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; b.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat temp_b;</span><br><span class="line">		b.<span class="built_in">row</span>(row).<span class="built_in">copyTo</span>(temp_b);</span><br><span class="line">		cv::Mat temp_b_reshape = temp_b.<span class="built_in">reshape</span>(<span class="number">0</span>, N1);</span><br><span class="line">		b_reshape.<span class="built_in">push_back</span>(temp_b_reshape);</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat sum = cv::Mat::<span class="built_in">zeros</span>(N1, N2, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; b_reshape.<span class="built_in">size</span>(); num++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + b_reshape[num].<span class="built_in">mul</span>(b_reshape[num]);</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat rho;	</span><br><span class="line">	cv::<span class="built_in">sqrt</span>(sum, rho);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; b_reshape.<span class="built_in">size</span>(); num++)</span><br><span class="line">	&#123;	</span><br><span class="line">		n.<span class="built_in">push_back</span>(b_reshape[num] / rho);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">photometric_sfm</span><span class="params">(cv::Mat I, vector&lt;cv::Mat&gt; L, vector&lt;cv::Mat&gt; &amp;n, vector&lt;POINT_3D&gt; point_3d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> N1 = I.rows;</span><br><span class="line">	<span class="type">int</span> N2 = I.cols;</span><br><span class="line">	cv::Mat N = cv::Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, L.<span class="built_in">size</span>(), CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat I_col;</span><br><span class="line">		I.<span class="built_in">col</span>(i).<span class="built_in">copyTo</span>(I_col);</span><br><span class="line">		cv::Mat LL;</span><br><span class="line">		L[i].<span class="built_in">copyTo</span>(LL);</span><br><span class="line">		cv::Mat LL_t;<span class="comment">//转置</span></span><br><span class="line">		cv::<span class="built_in">transpose</span>(LL, LL_t);</span><br><span class="line">		cv::Mat LL_inv;<span class="comment">//取逆</span></span><br><span class="line">		cv::<span class="built_in">invert</span>(LL_t, LL_inv, cv::DECOMP_SVD);</span><br><span class="line">		<span class="type">double</span> LL_x = <span class="number">0</span>, LL_y = <span class="number">0</span>, LL_z = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; LL_inv.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			LL_x = LL_inv.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, col);</span><br><span class="line">			LL_y = LL_inv.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, col);</span><br><span class="line">			LL_z = LL_inv.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, col);</span><br><span class="line">			LL_inv.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, col) = LL_x / (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(LL_x, <span class="number">2</span>) + <span class="built_in">pow</span>(LL_y, <span class="number">2</span>) + <span class="built_in">pow</span>(LL_z, <span class="number">2</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">		cv::Mat b = LL_inv * I_col;</span><br><span class="line">		b.<span class="built_in">copyTo</span>(N.<span class="built_in">col</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat sum = N.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">mul</span>(N.<span class="built_in">row</span>(<span class="number">0</span>)) + N.<span class="built_in">row</span>(<span class="number">1</span>).<span class="built_in">mul</span>(N.<span class="built_in">row</span>(<span class="number">1</span>)) + N.<span class="built_in">row</span>(<span class="number">2</span>).<span class="built_in">mul</span>(N.<span class="built_in">row</span>(<span class="number">2</span>));</span><br><span class="line">	cv::Mat rho;</span><br><span class="line">	cv::<span class="built_in">sqrt</span>(sum, rho);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; N.rows; num++)</span><br><span class="line">	&#123;</span><br><span class="line">		n.<span class="built_in">push_back</span>(N.<span class="built_in">row</span>(num) / rho);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-func-points-3d-h"><a href="#4-func-points-3d-h" class="headerlink" title="4.func_points_3d.h"></a>4.func_points_3d.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;struct_sfm_type.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_points3d_txt</span><span class="params">(string path, vector&lt;POINT_3D&gt;&amp;point_3d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获得points3D中的内容</span></span><br><span class="line">	string line;</span><br><span class="line">	ifstream fin;</span><br><span class="line">	fin.<span class="built_in">open</span>(path + <span class="string">&quot;points3D.txt&quot;</span>);</span><br><span class="line">	<span class="built_in">getline</span>(fin, line);</span><br><span class="line">	<span class="built_in">getline</span>(fin, line);</span><br><span class="line">	<span class="built_in">getline</span>(fin, line);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(fin, line))</span><br><span class="line">	&#123;</span><br><span class="line">		stringstream ss;</span><br><span class="line">		POINT_3D temp_point;</span><br><span class="line">		ss &lt;&lt; line;</span><br><span class="line">		ss &gt;&gt; temp_point.point3d_id;</span><br><span class="line">		ss &gt;&gt; temp_point.X;</span><br><span class="line">		ss &gt;&gt; temp_point.Y;</span><br><span class="line">		ss &gt;&gt; temp_point.Z;</span><br><span class="line">		ss &gt;&gt; temp_point.R;</span><br><span class="line">		ss &gt;&gt; temp_point.G;</span><br><span class="line">		ss &gt;&gt; temp_point.B;</span><br><span class="line">		ss &gt;&gt; temp_point.ERROR_S;</span><br><span class="line">		<span class="type">int</span> temp_ID;</span><br><span class="line">		<span class="type">int</span> temp_IDX;</span><br><span class="line">		<span class="keyword">while</span> (ss)</span><br><span class="line">		&#123;</span><br><span class="line">			ss &gt;&gt; temp_ID;</span><br><span class="line">			temp_point.IMAGE_ID.<span class="built_in">push_back</span>(temp_ID);</span><br><span class="line">			ss &gt;&gt; temp_IDX;</span><br><span class="line">			temp_point.POINT2D_IDX.<span class="built_in">push_back</span>(temp_IDX);</span><br><span class="line">		&#125;</span><br><span class="line">		temp_point.IMAGE_ID.<span class="built_in">pop_back</span>();</span><br><span class="line">		temp_point.POINT2D_IDX.<span class="built_in">pop_back</span>();</span><br><span class="line">		point_3d.<span class="built_in">push_back</span>(temp_point);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//meshlab剔除点云中的离群点，通过该函数将point_3d中的对应点剔除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_points</span><span class="params">(string path, vector&lt;POINT_3D&gt; &amp;point_3d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//读取pcl文件，得到X,Y,Z</span></span><br><span class="line">	pcl::PLYReader reader;</span><br><span class="line">	pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">	reader.<span class="built_in">read</span>&lt;pcl::PointXYZ&gt;(path + <span class="string">&quot;points_cloud.ply&quot;</span>, *cloud);</span><br><span class="line">	<span class="type">int</span> points_count = cloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;POINT_3D&gt;::iterator it = point_3d.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_3d.<span class="built_in">size</span>() &amp;&amp; it != point_3d.<span class="built_in">end</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; points_count; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (point_3d[i].X - cloud-&gt;points[j].x &lt; <span class="number">0.1</span></span><br><span class="line">				&amp;&amp;point_3d[i].Y - cloud-&gt;points[j].y &lt; <span class="number">0.1</span></span><br><span class="line">				&amp;&amp;point_3d[i].Z - cloud-&gt;points[j].z &lt; <span class="number">0.1</span>)</span><br><span class="line">				it++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				it = point_3d.<span class="built_in">erase</span>(it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-func-images-h"><a href="#5-func-images-h" class="headerlink" title="5.func_images.h"></a>5.func_images.h</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;struct_sfm_type.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void read_images_txt(string path, vector&lt;POINT_2D&gt;&amp;point_2d, vector&lt;QUATERNION&gt;&amp;quaternion)</span><br><span class="line">&#123;</span><br><span class="line">	string in_file_name = &quot;images.txt&quot;;</span><br><span class="line">	ifstream infile(path + in_file_name);</span><br><span class="line">	string line;</span><br><span class="line">	string::size_type idx;</span><br><span class="line">	string belong_img;</span><br><span class="line"></span><br><span class="line">	getline(infile, line);</span><br><span class="line">	getline(infile, line);</span><br><span class="line">	getline(infile, line);</span><br><span class="line">	getline(infile, line);</span><br><span class="line"></span><br><span class="line">	//获得images.txt中的内容</span><br><span class="line">	int image_id = 0;</span><br><span class="line">	while (getline(infile, line))</span><br><span class="line">	&#123;</span><br><span class="line">		idx = line.find(&quot;.bmp&quot;);		</span><br><span class="line">		if (idx != string::npos)//存在bmp</span><br><span class="line">		&#123;</span><br><span class="line">			istringstream record(line);</span><br><span class="line">			QUATERNION temp_data;</span><br><span class="line">			string data_read;</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.IMAGE_ID = stoi(data_read);</span><br><span class="line">			image_id = temp_data.IMAGE_ID;</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.QW = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.QX = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.QY = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.QZ = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.TX = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.TY = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.TZ = stod(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.CAMERA_ID = stoi(data_read);</span><br><span class="line"></span><br><span class="line">			record &gt;&gt; data_read;</span><br><span class="line">			temp_data.NAME = data_read;</span><br><span class="line">			quaternion.push_back(temp_data);</span><br><span class="line">			belong_img = data_read;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			istringstream record(line);</span><br><span class="line">			POINT_2D temp_data;</span><br><span class="line">			string data_read1, data_read2, data_read3;</span><br><span class="line">			while (record)</span><br><span class="line">			&#123;</span><br><span class="line">				record &gt;&gt; data_read1;//X</span><br><span class="line"></span><br><span class="line">				record &gt;&gt; data_read2;//Y</span><br><span class="line"></span><br><span class="line">				record &gt;&gt; data_read3;//ID</span><br><span class="line"></span><br><span class="line">				temp_data.X.push_back(stod(data_read1));</span><br><span class="line">				temp_data.Y.push_back(stod(data_read2));</span><br><span class="line">				temp_data.point3d_id.push_back(stoi(data_read3));</span><br><span class="line">				temp_data.belong_img = belong_img;</span><br><span class="line">				temp_data.IMAGE_ID = image_id;</span><br><span class="line">			&#125;</span><br><span class="line">			point_2d.push_back(temp_data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showManyImages(const vector&lt;cv::Mat&gt;&amp;srcImages) &#123;</span><br><span class="line">	int nNumImages = srcImages.size();</span><br><span class="line">	cv::Size nSizeWindows;</span><br><span class="line">	if (nNumImages &gt; 12) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;no more tha 12 images&quot; &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//根据图片序列数量来确定分割小窗口的形态</span><br><span class="line">	switch (nNumImages) &#123;</span><br><span class="line">	case 1:nSizeWindows = cv::Size(1, 1); break;</span><br><span class="line">	case 2:nSizeWindows = cv::Size(2, 1); break;</span><br><span class="line">	case 3:</span><br><span class="line">	case 4:nSizeWindows = cv::Size(2, 2); break;</span><br><span class="line">	case 5:</span><br><span class="line">	case 6:nSizeWindows = cv::Size(3, 2); break;</span><br><span class="line">	case 7:</span><br><span class="line">	case 8:nSizeWindows = cv::Size(4, 2); break;</span><br><span class="line">	case 9:nSizeWindows = cv::Size(3, 3); break;</span><br><span class="line">	default:nSizeWindows = cv::Size(4, 3);</span><br><span class="line">	&#125;</span><br><span class="line">	//设置小图像尺寸，间隙，边界</span><br><span class="line">	int nShowImageSize = 400;</span><br><span class="line">	int nSplitLineSize = 15;</span><br><span class="line">	int nAroundLineSize = 50;</span><br><span class="line">	//创建输出图像，图像大小根据输入源来确定</span><br><span class="line">	const int imagesHeight = nShowImageSize *</span><br><span class="line">		nSizeWindows.width + nAroundLineSize +</span><br><span class="line">		(nSizeWindows.width - 1)*nSplitLineSize;</span><br><span class="line">	const int imagesWidth = nShowImageSize *</span><br><span class="line">		nSizeWindows.height + nAroundLineSize +</span><br><span class="line">		(nSizeWindows.height - 1)*nSplitLineSize;</span><br><span class="line">	cout &lt;&lt; imagesWidth &lt;&lt; &quot;  &quot; &lt;&lt; imagesHeight &lt;&lt; endl;</span><br><span class="line">	cv::Mat showWindowsImages(imagesWidth, imagesHeight, CV_8UC3, cv::Scalar(0, 0, 0));</span><br><span class="line">	//提取对应小图像的左上角坐标x，y</span><br><span class="line">	int posX = (showWindowsImages.cols - (nShowImageSize*nSizeWindows.width +</span><br><span class="line">		(nSizeWindows.width - 1)*nSplitLineSize)) / 2;</span><br><span class="line">	int posY = (showWindowsImages.rows - (nShowImageSize*nSizeWindows.height +</span><br><span class="line">		(nSizeWindows.height - 1)*nSplitLineSize)) / 2;</span><br><span class="line">	cout &lt;&lt; posX &lt;&lt; &quot;  &quot; &lt;&lt; posY &lt;&lt; endl;</span><br><span class="line">	int tempPosX = posX;</span><br><span class="line">	int tempPosY = posY;</span><br><span class="line">	//将每一幅小图像整合成一幅大图像</span><br><span class="line">	for (int i = 0; i &lt; nNumImages; i++) &#123;</span><br><span class="line">		//小图像坐标转换</span><br><span class="line">		if ((i%nSizeWindows.width == 0) &amp;&amp; (tempPosX != posX)) &#123;</span><br><span class="line">			tempPosX = posX;;</span><br><span class="line">			tempPosY += (nSplitLineSize + nShowImageSize);</span><br><span class="line">		&#125;</span><br><span class="line">		//利用Rect区域将小图像置于大图像的相应区域</span><br><span class="line">		cv::Mat tempImage = showWindowsImages</span><br><span class="line">		(cv::Rect(tempPosX, tempPosY, nShowImageSize, nShowImageSize));</span><br><span class="line">		//利用resize函数实现图像缩放</span><br><span class="line">		resize(srcImages[i], tempImage,</span><br><span class="line">			cv::Size(nShowImageSize, nShowImageSize));</span><br><span class="line">		tempPosX += (nSplitLineSize + nShowImageSize);</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(&quot;showWindowImages&quot;, showWindowsImages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_camera_txt(string path, vector&lt;CAMERA&gt;&amp;cameras)</span><br><span class="line">&#123;</span><br><span class="line">	ifstream cameras_file_in;</span><br><span class="line">	string line;</span><br><span class="line">	cameras_file_in.open(path + &quot;cameras.txt&quot;);</span><br><span class="line">	getline(cameras_file_in, line);</span><br><span class="line">	getline(cameras_file_in, line);</span><br><span class="line">	getline(cameras_file_in, line);</span><br><span class="line">	while (getline(cameras_file_in, line))</span><br><span class="line">	&#123;</span><br><span class="line">		stringstream ss;</span><br><span class="line">		CAMERA temp_data;</span><br><span class="line">		ss &lt;&lt; line;</span><br><span class="line">		ss &gt;&gt; temp_data.CAMERA_ID;</span><br><span class="line">		ss &gt;&gt; temp_data.MODEL;</span><br><span class="line">		ss &gt;&gt; temp_data.WIDTH;</span><br><span class="line">		ss &gt;&gt; temp_data.HEIGHT;</span><br><span class="line">		ss &gt;&gt; temp_data.f;</span><br><span class="line">		ss &gt;&gt; temp_data.u;</span><br><span class="line">		ss &gt;&gt; temp_data.v;</span><br><span class="line">		ss &gt;&gt; temp_data.unknown;</span><br><span class="line">		cameras.push_back(temp_data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix3d Quaternion2RotationMatrix(double x, double y, double z, double w)</span><br><span class="line">&#123;</span><br><span class="line">	Eigen::Quaterniond q;</span><br><span class="line">	q.x() = x;</span><br><span class="line">	q.y() = y;</span><br><span class="line">	q.z() = z;</span><br><span class="line">	q.w() = w;</span><br><span class="line">	Eigen::Matrix3d R = q.normalized().toRotationMatrix();</span><br><span class="line">	return R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、源文件"><a href="#二、源文件" class="headerlink" title="二、源文件"></a>二、源文件</h4><h4 id="1-test-ps-h（计算法向-重建）"><a href="#1-test-ps-h（计算法向-重建）" class="headerlink" title="1.test_ps.h（计算法向+重建）"></a>1.test_ps.h（计算法向+重建）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;INCLUDE_FILES.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string g_src = <span class="string">&quot;F:\\PS_2022\\2022-3-1\\3\\ps\\&quot;</span>;</span><br><span class="line"><span class="comment">//string g_src = &quot;F:\\2021-4-25\\bk\\&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据shadowThresh生成maskshadow</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maskshadow</span><span class="params">(vector&lt;cv::Mat&gt; imgs, vector&lt;cv::Mat&gt; &amp;mask, <span class="type">double</span> shadowThresh, <span class="type">int</span> g_pic_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Mat se;</span><br><span class="line">	se = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_ELLIPSE, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g_pic_num; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat temp = cv::<span class="built_in">Mat</span>(imgs[k].rows, imgs[k].cols, CV_64FC1);</span><br><span class="line">		<span class="type">double</span>* data;</span><br><span class="line">		<span class="type">double</span>* tmp;</span><br><span class="line">		<span class="comment">//遍历图像</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; imgs[k].rows; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			data = imgs[k].<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);<span class="comment">//行指针</span></span><br><span class="line">			tmp = temp.<span class="built_in">ptr</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; imgs[k].cols; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (data[j] &gt; shadowThresh)</span><br><span class="line">					tmp[j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tmp[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cv::Mat dst;<span class="comment">//输出图像</span></span><br><span class="line">		cv::<span class="built_in">erode</span>(temp, dst, se);</span><br><span class="line">		mask.<span class="built_in">push_back</span>(dst);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat数据转vector</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">vector&lt;_Tp&gt; <span class="title">convertMat2Vector</span><span class="params">(<span class="type">const</span> cv::Mat &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (vector&lt;_Tp&gt;)(mat.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三个单通道图像转三通道图像</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">convertTo3Channels</span><span class="params">(cv::Mat Img1, cv::Mat Img2, cv::Mat Img3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Mat three_channel = cv::Mat::<span class="built_in">zeros</span>(Img1.rows, Img1.cols, CV_64FC3);</span><br><span class="line">	vector&lt;cv::Mat&gt; channels;</span><br><span class="line">	channels.<span class="built_in">push_back</span>(Img1);</span><br><span class="line">	channels.<span class="built_in">push_back</span>(Img2);</span><br><span class="line">	channels.<span class="built_in">push_back</span>(Img3);</span><br><span class="line">	<span class="built_in">merge</span>(channels, three_channel);</span><br><span class="line">	<span class="keyword">return</span> three_channel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泊松积分——注：必须为偶数行列，否则dct失效</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poisson_solver</span><span class="params">(cv::Mat p, cv::Mat q, cv::Mat &amp;Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> row = p.rows;</span><br><span class="line">	<span class="type">int</span> col = p.cols;</span><br><span class="line">	cv::Mat gxx = p.<span class="built_in">clone</span>();</span><br><span class="line">	cv::Mat gyy = q.<span class="built_in">clone</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			gxx.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = p.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) - p.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			gyy.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = q.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) - q.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i - <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat f = gxx + gyy;</span><br><span class="line">	cv::Mat fcos;</span><br><span class="line">	cv::<span class="built_in">dct</span>(f, fcos);</span><br><span class="line">	<span class="type">double</span> denom = <span class="number">0</span>;</span><br><span class="line">	col = col;</span><br><span class="line">	row = row;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		denom = <span class="number">2</span> * <span class="built_in">cos</span>(PI*(<span class="type">double</span>)j / col) - <span class="number">2</span> + <span class="number">2</span> * <span class="built_in">cos</span>(PI*<span class="number">0.0</span> / row) - <span class="number">2</span>;</span><br><span class="line">		fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, j) = fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, j) / denom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			denom = <span class="number">2</span> * <span class="built_in">cos</span>(PI*(<span class="type">double</span>)j / col) - <span class="number">2</span> + <span class="number">2</span> * <span class="built_in">cos</span>(PI*(<span class="type">double</span>)i / row) - <span class="number">2</span>;</span><br><span class="line">			fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) = fcos.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j) / denom;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cv::<span class="built_in">idct</span>(fcos, Z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Mat image = cv::<span class="built_in">imread</span>(g_src + <span class="string">&quot;0.bmp&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="function">cv::Rect <span class="title">rect</span><span class="params">(<span class="number">899</span>, <span class="number">1799</span>, <span class="number">1900</span>, <span class="number">1600</span>)</span></span>;</span><br><span class="line">	<span class="comment">//cv::Rect rect(0, 0, 1000, 1000);</span></span><br><span class="line">	<span class="type">int</span> g_pic_num = <span class="number">6</span>;</span><br><span class="line">	<span class="type">double</span> shadowThresh = <span class="number">0.05</span>;</span><br><span class="line">	cv::Mat L = cv::Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">6</span>, CV_64FC1);</span><br><span class="line">	<span class="type">double</span> Slant = <span class="number">45</span>;</span><br><span class="line">	<span class="type">double</span> Slant_sin = <span class="built_in">sin</span>(Slant / <span class="number">180</span> * PI);</span><br><span class="line">	<span class="type">double</span> Slant_cos = <span class="built_in">cos</span>(Slant / <span class="number">180</span> * PI);</span><br><span class="line">	<span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//double prctile[6] = &#123; 0.7098,0.7059,0.7333,0.7333,0.7176,0.7255 &#125;;</span></span><br><span class="line">	vector&lt;cv::Mat&gt; I;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= g_pic_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> numberI = (i - <span class="number">1</span>) * <span class="number">360</span> / g_pic_num;</span><br><span class="line">		cv::Mat image = cv::<span class="built_in">imread</span>(g_src + <span class="built_in">to_string</span>(numberI) + <span class="string">&quot;.bmp&quot;</span>);</span><br><span class="line">		vector&lt;cv::Mat&gt; BGRArray;</span><br><span class="line">		cv::<span class="built_in">split</span>(image, BGRArray);</span><br><span class="line">		cv::Mat image_double;</span><br><span class="line">		BGRArray[<span class="number">2</span>].<span class="built_in">convertTo</span>(image_double, CV_64FC1);</span><br><span class="line">		image_double = image_double / <span class="number">255.0</span>;</span><br><span class="line">		cv::Mat image_rect = <span class="built_in">image_double</span>(rect);</span><br><span class="line">		<span class="comment">//cv::Mat image_prctile = image_rect / prctile[i - 1];</span></span><br><span class="line">		cv::Mat image_prctile = image_rect;</span><br><span class="line">		I.<span class="built_in">push_back</span>(image_prctile);</span><br><span class="line">		L.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, temp) = Slant_sin * <span class="built_in">cos</span>(numberI * PI / <span class="number">180</span>);</span><br><span class="line">		L.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, temp) = Slant_sin * <span class="built_in">sin</span>(numberI * PI / <span class="number">180</span>);</span><br><span class="line">		L.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, temp) = Slant_cos;</span><br><span class="line">		temp++;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;cv::Mat&gt; shadow_mask;</span><br><span class="line">	<span class="built_in">maskshadow</span>(I, shadow_mask, shadowThresh, g_pic_num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> N1 = I[<span class="number">0</span>].rows;</span><br><span class="line">	<span class="type">int</span> N2 = I[<span class="number">0</span>].cols;</span><br><span class="line">	<span class="type">int</span> N = N1 * N2;</span><br><span class="line">	<span class="comment">//opencv 先转置，然后再reshaoe与matlab相同</span></span><br><span class="line">	<span class="comment">//图像矩阵 6×N</span></span><br><span class="line">	cv::Mat I_Rows = cv::Mat::<span class="built_in">zeros</span>(g_pic_num, N, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; I.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//转置</span></span><br><span class="line">		cv::Mat I_T;</span><br><span class="line">		cv::<span class="built_in">transpose</span>(I[i], I_T);</span><br><span class="line">		<span class="comment">//reshape</span></span><br><span class="line">		cv::Mat I_row = I_T.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		I_row.<span class="built_in">copyTo</span>(I_Rows.<span class="built_in">row</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//mask矩阵 N×6</span></span><br><span class="line">	cv::Mat Mask_cols = cv::Mat::<span class="built_in">zeros</span>(N, g_pic_num, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shadow_mask.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat shadow_mask_T;</span><br><span class="line">		cv::<span class="built_in">transpose</span>(shadow_mask[i], shadow_mask_T);</span><br><span class="line">		cv::Mat shadow_mask_col = shadow_mask_T.<span class="built_in">reshape</span>(<span class="number">0</span>, N);</span><br><span class="line">		shadow_mask_col.<span class="built_in">copyTo</span>(Mask_cols.<span class="built_in">col</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//maskIndex矩阵 N×1</span></span><br><span class="line">	cv::Mat maskIndex_mat = cv::Mat::<span class="built_in">zeros</span>(N, <span class="number">1</span>, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_pic_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maskIndex_mat = maskIndex_mat * <span class="number">2</span> + Mask_cols.<span class="built_in">col</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//maskIndex向量 N×1</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; maskIndex = <span class="built_in">convertMat2Vector</span>&lt;<span class="type">int</span>&gt;(maskIndex_mat);</span><br><span class="line">	<span class="comment">//unique_maskIndex消除maskIndex重复值</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; unique_maskIndex;</span><br><span class="line">	unique_maskIndex.<span class="built_in">assign</span>(maskIndex.<span class="built_in">begin</span>(),maskIndex.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">sort</span>(unique_maskIndex.<span class="built_in">begin</span>(), unique_maskIndex.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">auto</span> ite = <span class="built_in">unique</span>(unique_maskIndex.<span class="built_in">begin</span>(), unique_maskIndex.<span class="built_in">end</span>());</span><br><span class="line">	unique_maskIndex.<span class="built_in">erase</span>(ite, unique_maskIndex.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">//计算法向量</span></span><br><span class="line">	<span class="comment">//b矩阵 3×N</span></span><br><span class="line">	cv::Mat b = cv::Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, N, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> iIdx = <span class="number">0</span>; iIdx &lt; unique_maskIndex.<span class="built_in">size</span>(); iIdx++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> idx = unique_maskIndex[iIdx];</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; pixelIdx;</span><br><span class="line">		<span class="type">int</span> check_num = <span class="number">0</span>;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;::iterator iter = maskIndex.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> ((iter = std::<span class="built_in">find</span>(iter, maskIndex.<span class="built_in">end</span>(), idx)) != maskIndex.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> index1 = <span class="built_in">distance</span>(<span class="built_in">begin</span>(maskIndex), iter);</span><br><span class="line">			pixelIdx.<span class="built_in">push_back</span>(index1);</span><br><span class="line">			iter++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//imageTag向量 1×6</span></span><br><span class="line">		cv::Mat imageTag = cv::Mat::<span class="built_in">zeros</span>(<span class="number">1</span>, g_pic_num, CV_64FC1);</span><br><span class="line">		<span class="type">int</span> rows_pixelIdx = pixelIdx[<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_pic_num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			imageTag.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, i) = Mask_cols.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(rows_pixelIdx, i);</span><br><span class="line">			sum = sum + imageTag.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum &lt; <span class="number">4</span>	)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//Li矩阵</span></span><br><span class="line">		cv::Mat Li = cv::Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, sum, CV_64FC1);</span><br><span class="line">		<span class="type">int</span> Li_tag_num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; imageTag.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (imageTag.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, col) == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				L.<span class="built_in">col</span>(col).<span class="built_in">copyTo</span>(Li.<span class="built_in">col</span>(Li_tag_num));</span><br><span class="line">				Li_tag_num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Ii矩阵</span></span><br><span class="line">		cv::Mat Ii = cv::Mat::<span class="built_in">zeros</span>(sum, pixelIdx.<span class="built_in">size</span>(), CV_64FC1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pixelIdx.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pixelIdx_value = pixelIdx[i];</span><br><span class="line">			<span class="type">int</span> rows_num = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; imageTag.cols; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (imageTag.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, j) == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					Ii.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(rows_num, i) = I_Rows.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(j, pixelIdx_value);</span><br><span class="line">					rows_num++;</span><br><span class="line">				&#125;				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Li转置</span></span><br><span class="line">		cv::Mat Li_T;</span><br><span class="line">		cv::<span class="built_in">transpose</span>(Li, Li_T);</span><br><span class="line">		cv::Mat Li_T_inv;</span><br><span class="line">		cv::<span class="built_in">invert</span>(Li_T, Li_T_inv, cv::DECOMP_SVD);</span><br><span class="line">		cv::Mat b_temp = Li_T_inv * Ii;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pixelIdx.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pixelIdx_value = pixelIdx[i];</span><br><span class="line">			b.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, pixelIdx_value) = b_temp.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, i);</span><br><span class="line">			b.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, pixelIdx_value) = b_temp.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, i);</span><br><span class="line">			b.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, pixelIdx_value) = b_temp.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cv::Mat b_reshape1 = b.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">reshape</span>(<span class="number">0</span>, N2);</span><br><span class="line">	cv::Mat b_reshape1_T;</span><br><span class="line">	cv::<span class="built_in">transpose</span>(b_reshape1, b_reshape1_T);</span><br><span class="line"></span><br><span class="line">	cv::Mat b_reshape2 = b.<span class="built_in">row</span>(<span class="number">1</span>).<span class="built_in">reshape</span>(<span class="number">0</span>, N2);</span><br><span class="line">	cv::Mat b_reshape2_T;</span><br><span class="line">	cv::<span class="built_in">transpose</span>(b_reshape2, b_reshape2_T);</span><br><span class="line"></span><br><span class="line">	cv::Mat b_reshape3 = b.<span class="built_in">row</span>(<span class="number">2</span>).<span class="built_in">reshape</span>(<span class="number">0</span>, N2);</span><br><span class="line">	cv::Mat b_reshape3_T;</span><br><span class="line">	cv::<span class="built_in">transpose</span>(b_reshape3, b_reshape3_T);</span><br><span class="line"></span><br><span class="line">	vector&lt;cv::Mat&gt; b_mat_v;</span><br><span class="line">	b_mat_v.<span class="built_in">push_back</span>(b_reshape1_T);</span><br><span class="line">	b_mat_v.<span class="built_in">push_back</span>(b_reshape2_T);</span><br><span class="line">	b_mat_v.<span class="built_in">push_back</span>(b_reshape3_T);</span><br><span class="line">	cv::Mat rho_pow2 = b_reshape1_T.<span class="built_in">mul</span>(b_reshape1_T) + b_reshape2_T.<span class="built_in">mul</span>(b_reshape2_T) + b_reshape3_T.<span class="built_in">mul</span>(b_reshape3_T);</span><br><span class="line">	cv::Mat rho;</span><br><span class="line">	cv::<span class="built_in">sqrt</span>(rho_pow2, rho);</span><br><span class="line">	cv::Mat Normals = <span class="built_in">convertTo3Channels</span>(b_reshape3_T / rho, b_reshape2_T / rho, b_reshape1_T / rho);</span><br><span class="line">	cv::Mat p = cv::Mat::<span class="built_in">zeros</span>(b_reshape1_T.rows, b_reshape1_T.cols, CV_64FC1);</span><br><span class="line">	cv::Mat q = cv::Mat::<span class="built_in">zeros</span>(b_reshape1_T.rows, b_reshape1_T.cols, CV_64FC1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; p.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; p.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (b_reshape3_T.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) = <span class="number">0</span>;</span><br><span class="line">				q.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				p.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) = -b_reshape1_T.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) / b_reshape3_T.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col);</span><br><span class="line">				q.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) = -b_reshape2_T.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col) / b_reshape3_T.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(row, col);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat Z;</span><br><span class="line">	<span class="built_in">poisson_solver</span>(p, q, Z);</span><br><span class="line"></span><br><span class="line">	pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">	cloud-&gt;width = <span class="number">1900</span>;</span><br><span class="line">	cloud-&gt;height = <span class="number">1600</span>;</span><br><span class="line">	cloud-&gt;points.<span class="built_in">resize</span>(cloud-&gt;width*cloud-&gt;height);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Z.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Z.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cloud-&gt;points[i * <span class="number">1900</span> + j].x = j;</span><br><span class="line">			cloud-&gt;points[i * <span class="number">1900</span> + j].y = i;</span><br><span class="line">			cloud-&gt;points[i * <span class="number">1900</span> + j].z = Z.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//pcl::io::savePLYFile(std::string(path + &quot;sfm_points.ply&quot;), *cloud);</span></span><br><span class="line">	<span class="function">boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt; <span class="title">viewer</span><span class="params">(<span class="keyword">new</span> pcl::visualization::PCLVisualizer(<span class="string">&quot;3D Viewer&quot;</span>))</span></span>;</span><br><span class="line">	pcl::<span class="function">visualization::PointCloudColorHandlerGenericField&lt;pcl::PointXYZ&gt; <span class="title">fildColor</span><span class="params">(cloud, <span class="string">&quot;z&quot;</span>)</span></span>;</span><br><span class="line">	viewer-&gt;<span class="built_in">addPointCloud</span>&lt;pcl::PointXYZ&gt;(cloud, fildColor, <span class="string">&quot;sample cloud&quot;</span>);</span><br><span class="line">	viewer-&gt;<span class="built_in">setPointCloudRenderingProperties</span>(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, <span class="number">1</span>, <span class="string">&quot;sample cloud&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (!viewer-&gt;<span class="built_in">wasStopped</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		viewer-&gt;<span class="built_in">spinOnce</span>(<span class="number">100</span>);</span><br><span class="line">		boost::this_thread::<span class="built_in">sleep</span>(boost::posix_time::<span class="built_in">microseconds</span>(<span class="number">100000</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>传统光度立体</category>
      </categories>
      <tags>
        <tag>传统光度立体</tag>
      </tags>
  </entry>
</search>
